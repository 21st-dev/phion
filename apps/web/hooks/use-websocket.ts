"use client";

import { useEffect, useState, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

interface UseWebSocketOptions {
  projectId?: string;
  onFileTracked?: (data: any) => void;
  onSaveSuccess?: (data: any) => void;
  onError?: (error: any) => void;
  onAgentConnected?: (data: { projectId: string; clientId: string; timestamp: string }) => void;
  onAgentDisconnected?: (data: { projectId: string; clientId: string; timestamp: string }) => void;
  onDeployStatusUpdate?: (data: { 
    projectId: string; 
    status: string; 
    url?: string; 
    error?: string;
    timestamp: string 
  }) => void;
  onInitializationProgress?: (data: {
    projectId: string;
    stage: string;
    progress: number;
    message: string;
  }) => void;
  onCommitCreated?: (data: { projectId: string; commit: any; timestamp: number }) => void;
}

export function useWebSocket({ 
  projectId, 
  onFileTracked, 
  onSaveSuccess, 
  onError,
  onAgentConnected,
  onAgentDisconnected,
  onDeployStatusUpdate,
  onInitializationProgress,
  onCommitCreated
}: UseWebSocketOptions) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;
  const isConnecting = useRef(false);

  // –°—Ç–∞–±–∏–ª—å–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ callback —Ñ—É–Ω–∫—Ü–∏–∏
  const stableCallbacks = useRef({
    onFileTracked,
    onSaveSuccess,
    onError,
    onAgentConnected,
    onAgentDisconnected,
    onDeployStatusUpdate,
    onInitializationProgress,
    onCommitCreated
  });

  // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ callbacks –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
  useEffect(() => {
    stableCallbacks.current = {
      onFileTracked,
      onSaveSuccess,
      onError,
      onAgentConnected,
      onAgentDisconnected,
      onDeployStatusUpdate,
      onInitializationProgress,
      onCommitCreated
    };
  }, [onFileTracked, onSaveSuccess, onError, onAgentConnected, onAgentDisconnected, onDeployStatusUpdate, onInitializationProgress, onCommitCreated]);

  const disconnect = useCallback(() => {
    if (socket) {
      console.log('üõë [WebSocket] Manually disconnecting...');
      socket.disconnect();
      setSocket(null);
      setIsConnected(false);
      isConnecting.current = false;
    }
  }, [socket]);

  useEffect(() => {
    if (!projectId || isConnecting.current) {
      return;
    }

    console.log('üîå [WebSocket] Initializing connection for project:', projectId);
    isConnecting.current = true;

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    const newSocket = io(process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080', {
      transports: ['websocket'],
      autoConnect: true,
      timeout: 5000,
      reconnection: true,
      reconnectionAttempts: maxReconnectAttempts,
      reconnectionDelay: 2000,
      forceNew: true, // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    });

    newSocket.on('connect', () => {
      console.log('‚úÖ [WebSocket] Connected to server');
      setIsConnected(true);
      setConnectionError(null);
      reconnectAttempts.current = 0;
      isConnecting.current = false;
      
      // –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
      console.log('üîê [WebSocket] Authenticating for project:', projectId);
      newSocket.emit('authenticate', { 
        projectId,
        clientType: 'web'
      });
    });

    newSocket.on('authenticated', (data) => {
      console.log('‚úÖ [WebSocket] Authenticated:', data);
    });

    newSocket.on('disconnect', (reason) => {
      console.log('‚ùå [WebSocket] Disconnected:', reason);
      setIsConnected(false);
      isConnecting.current = false;
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ–º –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏
      if (reason === 'io server disconnect' && reconnectAttempts.current < maxReconnectAttempts) {
        setTimeout(() => {
          reconnectAttempts.current++;
          console.log(`üîÑ [WebSocket] Reconnection attempt ${reconnectAttempts.current}/${maxReconnectAttempts}`);
          newSocket.connect();
        }, 1000 * reconnectAttempts.current);
      }
    });

    newSocket.on('connect_error', (error) => {
      console.error('‚ùå [WebSocket] Connection error:', error);
      setConnectionError('Failed to connect to server');
      setIsConnected(false);
      isConnecting.current = false;
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π —Ñ–∞–π–ª–æ–≤
    newSocket.on('file_tracked', (data) => {
      console.log('üìù [WebSocket] File tracked:', data);
      stableCallbacks.current.onFileTracked?.(data);
    });

    // –ù–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ –¥–ª—è staged –∏–∑–º–µ–Ω–µ–Ω–∏–π
    newSocket.on('file_change_staged', (data) => {
      console.log('üìù [WebSocket] File change staged received:', {
        projectId: data.projectId,
        filePath: data.filePath,
        action: data.action,
        status: data.status,
        contentLength: data.content?.length || 0
      });
      stableCallbacks.current.onFileTracked?.(data);
    });

    newSocket.on('save_success', (data) => {
      console.log('üíæ [WebSocket] Save success:', data);
      stableCallbacks.current.onSaveSuccess?.(data);
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è discard_success (–æ—á–∏—Å—Ç–∫–∞ pending changes –ø—Ä–∏ –æ—Ç–∫–∞—Ç–µ)
    newSocket.on('discard_success', (data) => {
      console.log('üîÑ [WebSocket] Discard success:', data);
      stableCallbacks.current.onSaveSuccess?.(data); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ callback –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ pending changes
    });

    newSocket.on('agent_connected', (data) => {
      console.log('üü¢ [WebSocket] Agent connected:', data);
      stableCallbacks.current.onAgentConnected?.(data);
    });

    newSocket.on('agent_disconnected', (data) => {
      console.log('üî¥ [WebSocket] Agent disconnected:', data);
      stableCallbacks.current.onAgentDisconnected?.(data);
    });

    newSocket.on('deploy_status_update', (data) => {
      console.log('üöÄ [WebSocket] Deploy status update:', data);
      stableCallbacks.current.onDeployStatusUpdate?.(data);
    });

    newSocket.on('commit_created', (data) => {
      console.log('üìù [WebSocket] Commit created:', data);
      stableCallbacks.current.onCommitCreated?.(data);
    });

    newSocket.on('initialization_progress', (data) => {
      console.log('üìä [WebSocket] Initialization progress:', data);
      stableCallbacks.current.onInitializationProgress?.(data);
    });

    newSocket.on('file_updated', (data) => {
      console.log('üìÑ [WebSocket] File updated:', data);
      // –§–∞–π–ª –æ–±–Ω–æ–≤–ª–µ–Ω –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    });

    newSocket.on('files_saved', (data) => {
      console.log('üíæ [WebSocket] Files saved:', data);
      // –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    });

    newSocket.on('error', (error) => {
      console.error('‚ùå [WebSocket] Error:', error);
      stableCallbacks.current.onError?.(error);
    });

    setSocket(newSocket);

    // Cleanup –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
    return () => {
      console.log('üõë [WebSocket] Disconnecting...');
      isConnecting.current = false;
      newSocket.disconnect();
      setSocket(null);
      setIsConnected(false);
    };
  }, [projectId]); // –¢–æ–ª—å–∫–æ projectId –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–±—ã—Ç–∏–π
  const saveAllChanges = useCallback((commitMessage?: string) => {
    if (socket && isConnected) {
      socket.emit('save_all_changes', { 
        projectId, 
        commitMessage 
      });
    } else {
      stableCallbacks.current.onError?.({ message: 'Not connected to server' });
    }
  }, [socket, isConnected, projectId]);

  const discardAllChanges = useCallback(() => {
    if (socket && isConnected) {
      socket.emit('discard_all_changes', { 
        projectId 
      });
    } else {
      stableCallbacks.current.onError?.({ message: 'Not connected to server' });
    }
  }, [socket, isConnected, projectId]);

  return {
    socket,
    isConnected,
    connectionError,
    saveAllChanges,
    discardAllChanges,
    disconnect,
  };
} 