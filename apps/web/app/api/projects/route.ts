import { NextRequest, NextResponse } from "next/server";
import { getAllProjects, createProject, getUserProjects } from "@shipvibes/database";
import { createAuthServerClient } from "@shipvibes/database";
import { uploadProjectTemplate, uploadTextFile } from "@shipvibes/storage";
import { cookies } from "next/headers";
import path from "path";
import fs from "fs";
import archiver from "archiver";

export async function GET(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const supabase = createAuthServerClient({
      getAll() {
        return cookieStore.getAll();
      },
      setAll(cookiesToSet) {
        try {
          cookiesToSet.forEach(({ name, value, options }) =>
            cookieStore.set(name, value, options)
          );
        } catch {
          // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ cookies
        }
      },
    });

    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ–µ–∫—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (RLS –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç)
    const projects = await getUserProjects();
    return NextResponse.json(projects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    return NextResponse.json(
      { error: "Failed to fetch projects" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const supabase = createAuthServerClient({
      getAll() {
        return cookieStore.getAll();
      },
      setAll(cookiesToSet) {
        try {
          cookiesToSet.forEach(({ name, value, options }) =>
            cookieStore.set(name, value, options)
          );
        } catch {
          // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ cookies
        }
      },
    });

    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { name, template_type } = body;

    if (!name || !template_type) {
      return NextResponse.json(
        { error: "Name and template_type are required" },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–µ–∫—Ç —Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    const project = await createProject({
      name,
      template_type,
      user_id: user.id, // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ —Ç–µ–∫—É—â–µ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    });

    // –¢–û–õ–¨–ö–û —Å–æ–∑–¥–∞–µ–º ZIP —à–∞–±–ª–æ–Ω–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)
    try {
      await generateAndUploadTemplate(project.id, template_type, name);
    } catch (templateError) {
      console.error("Error generating template:", templateError);
      // –ü—Ä–æ–µ–∫—Ç —É–∂–µ —Å–æ–∑–¥–∞–Ω, –Ω–æ —à–∞–±–ª–æ–Ω –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω
    }

    // TODO: –°–æ–∑–¥–∞–Ω–∏–µ —Å–∞–π—Ç–∞ –Ω–∞ Netlify

    return NextResponse.json({
      project,
      downloadUrl: `/api/projects/${project.id}/download`,
    });
  } catch (error) {
    console.error("Error creating project:", error);
    return NextResponse.json(
      { error: "Failed to create project" },
      { status: 500 }
    );
  }
}

async function generateAndUploadTemplate(
  projectId: string,
  templateType: string,
  projectName: string
): Promise<void> {
  // –ü—É—Ç—å –∫ —à–∞–±–ª–æ–Ω—É (–ø–æ–¥–Ω–∏–º–∞–µ–º—Å—è –Ω–∞ 2 —É—Ä–æ–≤–Ω—è –≤–≤–µ—Ä—Ö –∏–∑ apps/web)
  const templatePath = path.join(process.cwd(), "..", "..", "templates", templateType);
  
  console.log(`Looking for template at: ${templatePath}`);
  
  if (!fs.existsSync(templatePath)) {
    throw new Error(`Template ${templateType} not found at ${templatePath}`);
  }

  console.log(`‚úÖ Template found, creating ZIP archive...`);
  
  // –°–æ–∑–¥–∞–µ–º ZIP –∞—Ä—Ö–∏–≤ —à–∞–±–ª–æ–Ω–∞
  const zipBuffer = await createTemplateZip(templatePath, projectName, projectId);
  
  console.log(`‚úÖ ZIP archive created, size: ${zipBuffer.length} bytes`);
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ R2
  console.log(`üì§ Uploading to R2 for project ${projectId}...`);
  const uploadResult = await uploadProjectTemplate(projectId, zipBuffer);
  
  console.log(`‚úÖ Upload successful:`, uploadResult);
}

async function createTemplateZip(templatePath: string, projectName: string, projectId: string): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const archive = archiver('zip', { zlib: { level: 9 } });
    const chunks: Uint8Array[] = [];

    archive.on('data', (chunk: Uint8Array) => chunks.push(chunk));
    archive.on('end', () => resolve(Buffer.concat(chunks)));
    archive.on('error', reject);

    // –ß–∏—Ç–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –∏–∑ —à–∞–±–ª–æ–Ω–∞
    const files = fs.readdirSync(templatePath, { withFileTypes: true });
    
    for (const file of files) {
      const filePath = path.join(templatePath, file.name);
      
      if (file.isDirectory()) {
        // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
        archive.directory(filePath, file.name);
      } else if (file.name === 'package.json') {
        // –û–±–Ω–æ–≤–ª—è–µ–º package.json —Å –∏–º–µ–Ω–µ–º –ø—Ä–æ–µ–∫—Ç–∞
        const packageJson = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        packageJson.name = projectName.toLowerCase().replace(/\s+/g, '-');
        archive.append(JSON.stringify(packageJson, null, 2), { name: 'package.json' });
      } else if (file.name === 'shipvibes-dev.js') {
        // –û–±–Ω–æ–≤–ª—è–µ–º shipvibes-dev.js —Å PROJECT_ID
        let agentContent = fs.readFileSync(filePath, 'utf-8');
        agentContent = agentContent.replace(/__PROJECT_ID__/g, projectId);
        archive.append(agentContent, { name: 'shipvibes-dev.js' });
      } else {
        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –∫–∞–∫ –µ—Å—Ç—å
        archive.file(filePath, { name: file.name });
      }
    }

    archive.finalize();
  });
}

