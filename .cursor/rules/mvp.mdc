---
description: 
globs: 
alwaysApply: false
---
TODO-план для MVP платформы Shipvibes.dev

Этот план описывает минимально жизнеспособный продукт (MVP) платформы Shipvibes.dev, которая генерирует шаблон фронтенд-проекта и отслеживает изменения файлов в реальном времени. Ниже приведен четкий поэтапный план разработки, включая структуру Turborepo монорепозитория, ключевые файлы/модули и их назначение, а также шаги по реализации функциональности с использованием Supabase и Cloudflare R2.

1. Структура Turborepo монорепозитория и базовая настройка

Первые шаги – настроить Turborepo монорепозиторий и необходимые сервисы (Supabase для БД, R2 для файлов). Создаем основу проекта с разделением на приложения и пакеты:

```
shipvibes/
├── apps/
│   ├── web/                          # Next.js App Router приложение
│   │   ├── app/                      # App Router структура
│   │   │   ├── page.tsx              # Главная страница
│   │   │   ├── project/[id]/page.tsx # Страница проекта
│   │   │   ├── api/                  # API Routes
│   │   │   │   ├── projects/route.ts # CRUD операции с проектами
│   │   │   │   └── auth/             # Аутентификация
│   │   │   └── globals.css           # Глобальные стили
│   │   ├── components/               # React компоненты
│   │   │   ├── project-list.tsx      # Список проектов
│   │   │   ├── file-history.tsx      # История изменений файлов
│   │   │   ├── diff-viewer.tsx       # Просмотр диффов
│   │   │   └── ui/                   # UI компоненты
│   │   ├── lib/                      # Утилиты и конфигурация
│   │   │   ├── supabase.ts           # Supabase клиент
│   │   │   └── utils.ts              # Общие утилиты
│   │   ├── next.config.js            # Next.js конфигурация
│   │   ├── tailwind.config.js        # Tailwind CSS конфигурация
│   │   └── package.json              # Зависимости веб-приложения
│   │
│   └── websocket-server/             # WebSocket сервер
│       ├── src/
│       │   ├── index.ts              # Основной сервер
│       │   ├── handlers/             # Обработчики WebSocket событий
│       │   │   ├── file-changes.ts   # Обработка изменений файлов
│       │   │   └── project-sync.ts   # Синхронизация проектов
│       │   ├── services/             # Бизнес-логика
│       │   │   ├── diff.ts           # Вычисление диффов
│       │   │   ├── deploy.ts         # Интеграция с Netlify
│       │   │   └── storage.ts        # Работа с R2
│       │   └── types/                # TypeScript типы
│       ├── package.json              # Зависимости WebSocket сервера
│       └── tsconfig.json             # TypeScript конфигурация
│
├── packages/
│   ├── shared/                       # Общие типы и утилиты
│   │   ├── src/
│   │   │   ├── types/                # Общие TypeScript типы
│   │   │   │   ├── project.ts        # Типы проектов
│   │   │   │   ├── file-history.ts   # Типы истории файлов
│   │   │   │   └── websocket.ts      # Типы WebSocket сообщений
│   │   │   └── utils/                # Общие утилиты
│   │   │       ├── validation.ts     # Валидация данных
│   │   │       └── constants.ts      # Константы
│   │   ├── package.json              # Зависимости shared пакета
│   │   └── tsconfig.json             # TypeScript конфигурация
│   │
│   ├── database/                     # Supabase клиент и схемы
│   │   ├── src/
│   │   │   ├── client.ts             # Supabase клиент
│   │   │   ├── types.ts              # Типы базы данных
│   │   │   ├── migrations/           # SQL миграции
│   │   │   │   ├── 001_initial.sql   # Начальная схема
│   │   │   │   └── 002_file_history.sql # Таблица истории файлов
│   │   │   └── queries/              # Готовые запросы
│   │   │       ├── projects.ts       # Запросы для проектов
│   │   │       └── file-history.ts   # Запросы для истории файлов
│   │   ├── package.json              # Зависимости database пакета
│   │   └── tsconfig.json             # TypeScript конфигурация
│   │
│   └── storage/                      # Cloudflare R2 клиент
│       ├── src/
│       │   ├── client.ts             # R2 клиент
│       │   ├── types.ts              # Типы для работы с файлами
│       │   ├── operations/           # Операции с файлами
│       │   │   ├── upload.ts         # Загрузка файлов
│       │   │   ├── download.ts       # Скачивание файлов
│       │   │   └── versioning.ts     # Версионирование файлов
│       │   └── utils/                # Утилиты для работы с R2
│       │       ├── paths.ts          # Генерация путей файлов
│       │       └── compression.ts    # Сжатие архивов
│       ├── package.json              # Зависимости storage пакета
│       └── tsconfig.json             # TypeScript конфигурация
│
├── templates/                        # Шаблоны проектов
│   └── vite-react/                   # Базовый Vite + React шаблон
│       ├── package.json              # Зависимости шаблона
│       ├── vite.config.js            # Vite конфигурация
│       ├── index.html                # HTML шаблон
│       ├── src/
│       │   ├── main.jsx              # Точка входа React
│       │   ├── App.jsx               # Основной компонент
│       │   └── index.css             # Стили
│       ├── shipvibes-dev.js          # Локальный агент синхронизации
│       └── README.md                 # Инструкции для пользователя
│
├── turbo.json                        # Turborepo конфигурация
├── package.json                      # Корневые зависимости
├── pnpm-workspace.yaml               # PNPM workspace конфигурация
└── README.md                         # Документация проекта
```

Настройка окружения:
- Supabase проект с PostgreSQL базой данных
- Cloudflare R2 bucket для хранения файлов
- Переменные окружения для всех сервисов

2. Настройка базы данных Supabase (структура таблиц)

Создать таблицы в Supabase для хранения метаданных проектов и истории изменений:

```sql
-- packages/database/src/migrations/001_initial.sql
-- Таблица пользователей (используется Supabase Auth)
-- auth.users уже существует

-- Таблица проектов
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL DEFAULT 'Untitled Project',
  template_type TEXT NOT NULL DEFAULT 'vite-react',
  netlify_site_id TEXT,
  netlify_url TEXT,
  deploy_status TEXT DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Таблица истории файлов
CREATE TABLE file_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  file_path TEXT NOT NULL,
  r2_object_key TEXT NOT NULL, -- Путь к файлу в R2
  content_hash TEXT, -- SHA-256 хеш содержимого для дедупликации
  diff_text TEXT, -- Предвычисленный diff
  file_size INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Индексы для оптимизации запросов
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_file_history_project_id ON file_history(project_id);
CREATE INDEX idx_file_history_created_at ON file_history(created_at);
CREATE INDEX idx_file_history_file_path ON file_history(project_id, file_path, created_at);

-- Row Level Security (RLS)
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE file_history ENABLE ROW LEVEL SECURITY;

-- Политики безопасности
CREATE POLICY "Users can view own projects" ON projects
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create own projects" ON projects
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own projects" ON projects
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can view file history of own projects" ON file_history
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM projects 
      WHERE projects.id = file_history.project_id 
      AND projects.user_id = auth.uid()
    )
  );

CREATE POLICY "System can insert file history" ON file_history
  FOR INSERT WITH CHECK (true); -- WebSocket сервер использует service key
```

Организация файлов в R2:
```
projects/
├── {project_id}/
│   ├── template.zip              # Исходный шаблон проекта
│   ├── versions/
│   │   └── {version_id}/
│   │       ├── {file_path}       # Версии отдельных файлов
│   │       └── metadata.json     # Метаданные версии
│   └── builds/
│       └── {build_id}/
│           └── dist.zip          # Собранные артефакты для деплоя
```

3. Фронтенд: Next.js App Router приложение

Реализовать веб-интерфейс с использованием Next.js App Router:

```typescript
// apps/web/app/page.tsx - Главная страница
import { CreateProjectButton } from '@/components/create-project-button'
import { ProjectList } from '@/components/project-list'
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'

export default async function HomePage() {
  const supabase = createServerComponentClient({ cookies })
  const { data: { session } } = await supabase.auth.getSession()

  if (!session) {
    return <AuthForm />
  }

  const { data: projects } = await supabase
    .from('projects')
    .select('*')
    .order('created_at', { ascending: false })

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">Мои проекты</h1>
        <CreateProjectButton />
      </div>
      <ProjectList projects={projects || []} />
    </div>
  )
}
```

```typescript
// apps/web/app/api/projects/route.ts - API для создания проектов
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'
import { generateProjectTemplate } from '@shipvibes/storage'

export async function POST(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies })
  const { data: { session } } = await supabase.auth.getSession()

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  try {
    // Создаем проект в базе данных
    const { data: project, error } = await supabase
      .from('projects')
      .insert({
        user_id: session.user.id,
        name: `Project ${Date.now()}`,
        template_type: 'vite-react'
      })
      .select()
      .single()

    if (error) throw error

    // Генерируем шаблон проекта и загружаем в R2
    const templateZip = await generateProjectTemplate(project.id, 'vite-react')
    
    // Возвращаем ссылку на скачивание
    return NextResponse.json({
      project,
      downloadUrl: `/api/projects/${project.id}/download`
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create project' },
      { status: 500 }
    )
  }
}
```

```typescript
// apps/web/app/project/[id]/page.tsx - Страница проекта
import { FileHistory } from '@/components/file-history'
import { ProjectHeader } from '@/components/project-header'
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { notFound } from 'next/navigation'

interface ProjectPageProps {
  params: { id: string }
}

export default async function ProjectPage({ params }: ProjectPageProps) {
  const supabase = createServerComponentClient({ cookies })
  
  const { data: project } = await supabase
    .from('projects')
    .select('*')
    .eq('id', params.id)
    .single()

  if (!project) {
    notFound()
  }

  const { data: fileHistory } = await supabase
    .from('file_history')
    .select('*')
    .eq('project_id', params.id)
    .order('created_at', { ascending: false })

  return (
    <div className="container mx-auto px-4 py-8">
      <ProjectHeader project={project} />
      <FileHistory history={fileHistory || []} />
    </div>
  )
}
```

4. Шаблон проекта с локальным агентом

Подготовить минимальный шаблон Vite + React с интегрированным агентом синхронизации:

```javascript
// templates/vite-react/shipvibes-dev.js
#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const { spawn } = require('child_process')
const chokidar = require('chokidar')
const { io } = require('socket.io-client')
const crypto = require('crypto')

const PROJECT_ID = '__PROJECT_ID__' // Заменяется при генерации
const WS_URL = process.env.SHIPVIBES_WS_URL || 'wss://api.shipvibes.dev'

class ShipvibesAgent {
  constructor() {
    this.socket = null
    this.devServer = null
    this.watcher = null
  }

  async start() {
    console.log('🚀 Запуск Shipvibes Agent...')
    
    // Проверяем окружение
    await this.checkEnvironment()
    
    // Устанавливаем зависимости
    await this.installDependencies()
    
    // Запускаем dev сервер
    this.startDevServer()
    
    // Подключаемся к WebSocket
    this.connectWebSocket()
    
    // Запускаем file watcher
    this.startFileWatcher()
    
    console.log(`📱 Откройте https://shipvibes.dev/project/${PROJECT_ID} для просмотра изменений`)
  }

  async checkEnvironment() {
    // Проверяем Node.js
    if (!process.version) {
      throw new Error('Node.js не найден')
    }
    
    // Проверяем pnpm
    try {
      await this.execCommand('pnpm', ['--version'])
    } catch (error) {
      console.log('📦 Устанавливаем pnpm...')
      await this.execCommand('npm', ['install', '-g', 'pnpm'])
    }
  }

  async installDependencies() {
    console.log('📦 Устанавливаем зависимости...')
    await this.execCommand('pnpm', ['install'])
  }

  startDevServer() {
    console.log('🔥 Запускаем dev сервер...')
    this.devServer = spawn('pnpm', ['run', 'dev'], {
      stdio: ['inherit', 'pipe', 'pipe']
    })
    
    this.devServer.stdout.on('data', (data) => {
      const output = data.toString()
      if (output.includes('Local:')) {
        console.log('✅ Dev сервер запущен:', output.match(/http:\/\/localhost:\d+/)?.[0])
      }
    })
  }

  connectWebSocket() {
    console.log('🔌 Подключаемся к Shipvibes...')
    
    this.socket = io(WS_URL, {
      auth: {
        projectId: PROJECT_ID
      }
    })

    this.socket.on('connect', () => {
      console.log('✅ Подключено к Shipvibes')
    })

    this.socket.on('disconnect', () => {
      console.log('❌ Отключено от Shipvibes')
    })

    this.socket.on('file_saved', (data) => {
      console.log(`💾 Файл сохранен: ${data.file_path}`)
    })
  }

  startFileWatcher() {
    console.log('👀 Отслеживаем изменения файлов...')
    
    this.watcher = chokidar.watch('.', {
      ignored: [
        'node_modules/**',
        '.git/**',
        'dist/**',
        '.shipvibes/**',
        'shipvibes-dev.js'
      ],
      ignoreInitial: true
    })

    this.watcher.on('change', (filePath) => {
      this.handleFileChange(filePath)
    })

    this.watcher.on('add', (filePath) => {
      this.handleFileChange(filePath)
    })

    this.watcher.on('unlink', (filePath) => {
      this.handleFileDelete(filePath)
    })
  }

  async handleFileChange(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf-8')
      const hash = crypto.createHash('sha256').update(content).digest('hex')
      
      console.log(`📝 Изменен: ${filePath}`)
      
      this.socket?.emit('file_change', {
        projectId: PROJECT_ID,
        filePath: filePath.replace(/\\/g, '/'), // Нормализуем путь
        content,
        hash,
        timestamp: Date.now()
      })
    } catch (error) {
      console.error(`❌ Ошибка чтения файла ${filePath}:`, error.message)
    }
  }

  handleFileDelete(filePath) {
    console.log(`🗑️ Удален: ${filePath}`)
    
    this.socket?.emit('file_delete', {
      projectId: PROJECT_ID,
      filePath: filePath.replace(/\\/g, '/'),
      timestamp: Date.now()
    })
  }

  async execCommand(command, args) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, { stdio: 'inherit' })
      process.on('close', (code) => {
        if (code === 0) {
          resolve()
        } else {
          reject(new Error(`Command failed with code ${code}`))
        }
      })
    })
  }

  stop() {
    console.log('🛑 Останавливаем Shipvibes Agent...')
    
    this.watcher?.close()
    this.socket?.disconnect()
    this.devServer?.kill()
  }
}

// Запуск агента
const agent = new ShipvibesAgent()

process.on('SIGINT', () => {
  agent.stop()
  process.exit(0)
})

process.on('SIGTERM', () => {
  agent.stop()
  process.exit(0)
})

agent.start().catch((error) => {
  console.error('❌ Ошибка запуска:', error.message)
  process.exit(1)
})
```

5. WebSocket сервер для обработки изменений

Реализовать WebSocket сервер для приема и обработки изменений файлов:

```typescript
// apps/websocket-server/src/index.ts
import { Server } from 'socket.io'
import { createServer } from 'http'
import { handleFileChange, handleFileDelete } from './handlers/file-changes'
import { authenticateSocket } from './middleware/auth'

const server = createServer()
const io = new Server(server, {
  cors: {
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    methods: ['GET', 'POST']
  }
})

io.use(authenticateSocket)

io.on('connection', (socket) => {
  console.log(`Client connected: ${socket.id}`)
  
  const projectId = socket.handshake.auth.projectId
  socket.join(`project:${projectId}`)

  socket.on('file_change', async (data) => {
    try {
      await handleFileChange(data, socket)
    } catch (error) {
      console.error('Error handling file change:', error)
      socket.emit('error', { message: 'Failed to save file' })
    }
  })

  socket.on('file_delete', async (data) => {
    try {
      await handleFileDelete(data, socket)
    } catch (error) {
      console.error('Error handling file delete:', error)
      socket.emit('error', { message: 'Failed to delete file' })
    }
  })

  socket.on('disconnect', () => {
    console.log(`Client disconnected: ${socket.id}`)
  })
})

const PORT = process.env.PORT || 8080
server.listen(PORT, () => {
  console.log(`WebSocket server running on port ${PORT}`)
})
```

```typescript
// apps/websocket-server/src/handlers/file-changes.ts
import { Socket } from 'socket.io'
import { supabase } from '@shipvibes/database'
import { uploadFileVersion, generateDiff } from '@shipvibes/storage'
import { triggerDeploy } from '../services/deploy'

export async function handleFileChange(data: any, socket: Socket) {
  const { projectId, filePath, content, hash } = data

  // Проверяем, изменился ли файл (по хешу)
  const { data: lastVersion } = await supabase
    .from('file_history')
    .select('content_hash')
    .eq('project_id', projectId)
    .eq('file_path', filePath)
    .order('created_at', { ascending: false })
    .limit(1)
    .single()

  if (lastVersion?.content_hash === hash) {
    // Файл не изменился, пропускаем
    return
  }

  // Загружаем файл в R2
  const versionId = crypto.randomUUID()
  const r2ObjectKey = `projects/${projectId}/versions/${versionId}/${filePath}`
  
  await uploadFileVersion(r2ObjectKey, content)

  // Вычисляем diff с предыдущей версией
  let diffText = null
  if (lastVersion) {
    const previousContent = await downloadFileVersion(lastVersion.r2_object_key)
    diffText = generateDiff(previousContent, content)
  }

  // Сохраняем запись в базу данных
  const { error } = await supabase
    .from('file_history')
    .insert({
      project_id: projectId,
      file_path: filePath,
      r2_object_key: r2ObjectKey,
      content_hash: hash,
      diff_text: diffText,
      file_size: Buffer.byteLength(content, 'utf-8')
    })

  if (error) {
    throw error
  }

  // Уведомляем клиента об успешном сохранении
  socket.emit('file_saved', {
    filePath,
    versionId,
    timestamp: Date.now()
  })

  // Уведомляем веб-интерфейс через Supabase Realtime
  // (автоматически через изменения в таблице)

  // Опционально: запускаем деплой
  await triggerDeploy(projectId)
}
```

6. Интеграция с Netlify для автодеплоя

```typescript
// apps/websocket-server/src/services/deploy.ts
import { NetlifyAPI } from 'netlify'
import { supabase } from '@shipvibes/database'
import { downloadProjectFiles, buildProject } from '@shipvibes/storage'

const netlify = new NetlifyAPI(process.env.NETLIFY_ACCESS_TOKEN)

export async function triggerDeploy(projectId: string) {
  try {
    // Получаем информацию о проекте
    const { data: project } = await supabase
      .from('projects')
      .select('*')
      .eq('id', projectId)
      .single()

    if (!project) {
      throw new Error('Project not found')
    }

    // Обновляем статус деплоя
    await supabase
      .from('projects')
      .update({ deploy_status: 'building' })
      .eq('id', projectId)

    // Скачиваем последние файлы проекта из R2
    const projectFiles = await downloadProjectFiles(projectId)
    
    // Собираем проект
    const buildArtifacts = await buildProject(projectFiles)
    
    // Создаем сайт на Netlify (если еще не создан)
    if (!project.netlify_site_id) {
      const site = await netlify.createSite({
        body: {
          name: `shipvibes-${projectId.slice(0, 8)}`
        }
      })
      
      await supabase
        .from('projects')
        .update({ 
          netlify_site_id: site.id,
          netlify_url: site.url
        })
        .eq('id', projectId)
        
      project.netlify_site_id = site.id
      project.netlify_url = site.url
    }

    // Деплоим на Netlify
    const deploy = await netlify.createSiteDeploy({
      siteId: project.netlify_site_id,
      body: {
        files: buildArtifacts
      }
    })

    // Обновляем статус деплоя
    await supabase
      .from('projects')
      .update({ 
        deploy_status: deploy.state,
        netlify_url: deploy.deploy_ssl_url || project.netlify_url
      })
      .eq('id', projectId)

    console.log(`Deploy triggered for project ${projectId}: ${deploy.deploy_ssl_url}`)
  } catch (error) {
    console.error(`Deploy failed for project ${projectId}:`, error)
    
    await supabase
      .from('projects')
      .update({ deploy_status: 'failed' })
      .eq('id', projectId)
  }
}
```

7. Пакеты для работы с R2 и Supabase

```typescript
// packages/storage/src/client.ts
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3'

const r2Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!
  }
})

export async function uploadFileVersion(key: string, content: string): Promise<void> {
  await r2Client.send(new PutObjectCommand({
    Bucket: process.env.R2_BUCKET_NAME,
    Key: key,
    Body: content,
    ContentType: 'text/plain'
  }))
}

export async function downloadFileVersion(key: string): Promise<string> {
  const response = await r2Client.send(new GetObjectCommand({
    Bucket: process.env.R2_BUCKET_NAME,
    Key: key
  }))
  
  return await response.Body?.transformToString() || ''
}
```

```typescript
// packages/database/src/client.ts
import { createClient } from '@supabase/supabase-js'

export const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // Для серверных операций
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
)
```

8. Минимальная работоспособная версия (первый commit)

Структура для первого коммита:

```
shipvibes/
├── apps/
│   ├── web/                     # ✅ Next.js App Router приложение
│   └── websocket-server/        # ✅ WebSocket сервер
├── packages/
│   ├── shared/                  # ✅ Общие типы
│   ├── database/                # ✅ Supabase интеграция
│   └── storage/                 # ✅ R2 интеграция
├── templates/
│   └── vite-react/              # ✅ Шаблон с агентом
├── turbo.json                   # ✅ Turborepo конфигурация
└── package.json                 # ✅ Корневые зависимости
```

Тестовый сценарий:
1. Запустить `pnpm dev` в корне (запускает все приложения)
2. Открыть веб-интерфейс, зарегистрироваться через Supabase Auth
3. Создать новый проект - должен скачаться архив
4. Распаковать архив, запустить `node shipvibes-dev.js`
5. Изменить файл в редакторе - изменения должны появиться в веб-интерфейсе
6. Проверить деплой на Netlify

Ключевые особенности обновленного MVP:
- **Turborepo** для эффективного управления монорепозиторием
- **Next.js App Router** для современного веб-интерфейса
- **Supabase** для надежного хранения метаданных и аутентификации
- **Cloudflare R2** для масштабируемого хранения файлов
- **TypeScript** во всех пакетах для типобезопасности
- **Realtime обновления** через Supabase Realtime
- **Модульная архитектура** с переиспользуемыми пакетами

Этот план обеспечивает быструю разработку MVP с возможностью дальнейшего масштабирования и добавления новых функций.
